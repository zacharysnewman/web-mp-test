<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube Collector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #111827; /* bg-gray-900 */
            color: white;
        }
        #game-canvas {
            display: block;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to the canvas */
        }
        .ui-element {
            pointer-events: auto; /* Allow interaction with UI elements */
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- UI Overlay -->
    <div class="overlay flex flex-col items-center justify-center p-4">
        
        <!-- Join Game Screen -->
        <div id="join-screen" class="ui-element bg-gray-800 bg-opacity-80 p-8 rounded-lg shadow-xl text-center">
            <h1 class="text-4xl font-bold mb-4">Cube Collector</h1>
            <p class="text-gray-300 mb-6">Enter your name and join the game.</p>
            <input type="text" id="player-name-input" placeholder="Player Name" class="w-full px-4 py-2 rounded-md bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4">
            <button id="join-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-md transition duration-300">
                Join Game
            </button>
        </div>

        <!-- In-Game UI -->
        <div id="in-game-ui" class="hidden w-full h-full">
            <!-- Timer -->
            <div class="absolute top-4 left-1/2 -translate-x-1/2 bg-gray-800 bg-opacity-70 px-4 py-2 rounded-lg">
                <span class="text-2xl font-semibold">Time: <span id="timer">60</span></span>
            </div>
            <!-- Leaderboard -->
            <div class="absolute top-4 right-4 bg-gray-800 bg-opacity-70 p-4 rounded-lg w-64">
                <h3 class="text-xl font-bold mb-2 border-b border-gray-600 pb-1">Leaderboard</h3>
                <ul id="leaderboard">
                    <!-- Populated by JS -->
                </ul>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden ui-element bg-gray-800 bg-opacity-90 p-12 rounded-lg shadow-xl text-center">
            <h2 class="text-5xl font-bold mb-4">Game Over!</h2>
            <p class="text-2xl text-gray-300">The winner is <span id="winner-name" class="font-bold text-yellow-400"></span>!</p>
            <p class="mt-8 text-gray-400">A new game will start shortly...</p>
        </div>

    </div>

    <script>
        // --- Client-side Game Logic ---

        // --- Setup ---
        const socket = io();
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x1a202c); // Dark background

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        scene.add(directionalLight);

        // --- Game Objects & State ---
        let myPlayerId = null;
        const playerMeshes = {}; // Store three.js meshes for players
        const treasureMeshes = {}; // Store three.js meshes for treasures
        let targetPosition = new THREE.Vector3();
        let targetIndicator;

        // --- Floor ---
        const floorGeometry = new THREE.PlaneGeometry(60, 60);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568 }); // gray-700
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        scene.add(floor);

        // --- Camera Position ---
        camera.position.set(0, 30, 25);
        camera.lookAt(0, 0, 0);

        // --- Target Indicator (Client-side only) ---
        function createTargetIndicator() {
            const geometry = new THREE.RingGeometry(0.4, 0.5, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            targetIndicator = new THREE.Mesh(geometry, material);
            targetIndicator.rotation.x = -Math.PI / 2;
            targetIndicator.visible = false;
            scene.add(targetIndicator);
        }
        createTargetIndicator();

        // --- Event Listeners ---
        const joinButton = document.getElementById('join-button');
        const playerNameInput = document.getElementById('player-name-input');
        const joinScreen = document.getElementById('join-screen');
        const inGameUI = document.getElementById('in-game-ui');
        const gameOverScreen = document.getElementById('game-over-screen');

        joinButton.addEventListener('click', () => {
            const playerName = playerNameInput.value;
            socket.emit('joinGame', playerName);
            joinScreen.classList.add('hidden');
            inGameUI.classList.remove('hidden');
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Click to move
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('click', (event) => {
            if (!myPlayerId) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(floor);
            if (intersects.length > 0) {
                targetPosition.copy(intersects[0].point);
                targetIndicator.position.copy(targetPosition);
                targetIndicator.position.y = 0.01; // Slightly above floor
                targetIndicator.visible = true;
            }
        });

        // --- Socket.IO Handlers ---
        socket.on('gameJoined', (data) => {
            myPlayerId = data.id;
            console.log("Joined game! My ID:", myPlayerId);
            updateGameState(data.gameState);
        });
        
        socket.on('gameState', (state) => {
            updateGameState(state);
        });

        socket.on('gameOver', (winnerName) => {
            inGameUI.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            document.getElementById('winner-name').textContent = winnerName;

            // Hide meshes for the next round
            Object.values(playerMeshes).forEach(mesh => mesh.visible = false);
            Object.values(treasureMeshes).forEach(mesh => mesh.visible = false);

            setTimeout(() => {
                gameOverScreen.classList.add('hidden');
                // The server will either start a new game (triggering gameState)
                // or we wait for the join screen if the server resets.
                // For simplicity, we just show the in-game UI again.
                inGameUI.classList.remove('hidden');
            }, 10000); // Match server delay
        });

        // --- Game Logic Functions ---
        function updateGameState(state) {
            if (!myPlayerId) return;
            
            // Update Timer
            document.getElementById('timer').innerText = state.gameTimer;

            // Update Leaderboard
            const leaderboardEl = document.getElementById('leaderboard');
            leaderboardEl.innerHTML = state.leaderboard.map(p => 
                `<li class="flex justify-between text-gray-300 py-1">
                    <span>${p.name}</span>
                    <span class="font-semibold text-yellow-400">${p.score}</span>
                </li>`
            ).join('');

            // --- Sync Players ---
            const serverPlayerIds = Object.keys(state.players);
            // Remove disconnected players
            for (const localId in playerMeshes) {
                if (!serverPlayerIds.includes(localId)) {
                    scene.remove(playerMeshes[localId]);
                    delete playerMeshes[localId];
                }
            }
            // Add/Update players
            for (const id in state.players) {
                const pData = state.players[id];
                if (!playerMeshes[id]) {
                    const isMe = id === myPlayerId;
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshStandardMaterial({ color: isMe ? 0xe53e3e : 0x4299e1 }); // red-600 : blue-500
                    playerMeshes[id] = new THREE.Mesh(geometry, material);
                    playerMeshes[id].position.set(pData.x, pData.y, pData.z);
                    scene.add(playerMeshes[id]);
                } else {
                    // For other players, we just snap their position.
                    // A smoother approach would be to interpolate.
                    const mesh = playerMeshes[id];
                    if (id !== myPlayerId) {
                         mesh.position.lerp(new THREE.Vector3(pData.x, pData.y, pData.z), 0.3);
                    }
                }
            }

            // --- Sync Treasures ---
            const serverTreasureIds = state.treasures.map(t => t.id);
            // Remove collected treasures
            for (const localId in treasureMeshes) {
                if (!serverTreasureIds.includes(localId)) {
                    scene.remove(treasureMeshes[localId]);
                    delete treasureMeshes[localId];
                }
            }
            // Add new treasures
            state.treasures.forEach(tData => {
                if (!treasureMeshes[tData.id]) {
                    const geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                    const material = new THREE.MeshStandardMaterial({ color: 0xf6e05e, emissive: 0xb7791f }); // yellow-400
                    treasureMeshes[tData.id] = new THREE.Mesh(geometry, material);
                    treasureMeshes[tData.id].position.set(tData.x, tData.y, tData.z);
                    scene.add(treasureMeshes[tData.id]);
                }
            });
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const myPlayerMesh = playerMeshes[myPlayerId];

            if (myPlayerMesh) {
                const distanceToTarget = myPlayerMesh.position.distanceTo(targetPosition);

                // Move player towards target
                if (distanceToTarget > 0.1) {
                    const moveSpeed = 0.05;
                    const direction = new THREE.Vector3().subVectors(targetPosition, myPlayerMesh.position).normalize();
                    myPlayerMesh.position.add(direction.multiplyScalar(moveSpeed));

                    // Interpolate rotation
                    const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                    myPlayerMesh.quaternion.slerp(targetQuaternion, 0.15);

                    // Send updated position to server
                    socket.emit('move', myPlayerMesh.position);
                } else {
                    targetIndicator.visible = false;
                }
            }
            
            // Pulse the target indicator
            if (targetIndicator && targetIndicator.visible) {
                const scale = 1 + Math.sin(now * 0.01) * 0.1;
                targetIndicator.scale.set(scale, scale, scale);
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
