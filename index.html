<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Cube Collector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #111827;
            color: white;
        }
        #game-canvas { display: block; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .ui-element { pointer-events: auto; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6d28d9;
            border-radius: 50%;
            width: 24px; height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
</div>

<!-- UI Overlay -->
<div class="overlay flex flex-col items-center justify-center p-4">
    <!-- Join Game -->
    <div id="join-screen" class="ui-element bg-gray-800 bg-opacity-80 p-8 rounded-lg shadow-xl text-center w-full max-w-md">
        <h1 class="text-4xl font-bold mb-4">Cube Collector</h1>
        <p class="text-gray-300 mb-6">Enter your name and join the game.</p>
        <div class="flex items-center w-full mb-4">
            <input type="text" id="player-name-input" placeholder="Player Name"
                class="flex-grow px-4 py-2 rounded-md bg-gray-700 text-white border border-gray-600
                focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>
        <button id="join-button"
            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-md transition duration-300">
            Join Game
        </button>
    </div>

    <!-- In-Game UI -->
    <div id="in-game-ui" class="hidden w-full h-full">
        <!-- Timer -->
        <div class="absolute top-4 left-1/2 -translate-x-1/2 bg-gray-800 bg-opacity-70 px-4 py-2 rounded-lg">
            <span class="text-2xl font-semibold">Time: <span id="timer">60</span></span>
        </div>
        <!-- Leaderboard -->
        <div class="absolute top-4 right-4 bg-gray-800 bg-opacity-70 p-4 rounded-lg w-64">
            <h3 class="text-xl font-bold mb-2 border-b border-gray-600 pb-1">Leaderboard</h3>
            <ul id="leaderboard"></ul>
        </div>
    </div>

    <!-- Game Over -->
    <div id="game-over-screen" class="hidden ui-element bg-gray-800 bg-opacity-90 p-12 rounded-lg shadow-xl text-center max-w-lg">
        <h2 class="text-5xl font-bold mb-4">Game Over!</h2>
        <div id="winner-announcement" class="text-2xl text-gray-300 min-h-[6rem] flex items-center justify-center"></div>
        <p class="mt-8 text-gray-400">A new game will start shortly...</p>
    </div>
</div>

<script>
    const socket = io('https://web-mp-test.onrender.com');

    // THREE.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x1a202c);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 5);
    scene.add(directionalLight);

    // Game state
    let myPlayerId = null;
    const playerMeshes = {};
    const treasureMeshes = {};
    const targetPosition = new THREE.Vector3();
    let targetIndicator;

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(60, 60);
    floorGeometry.rotateX(-Math.PI / 2);
    const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -0.01;
    scene.add(floor);

    // Camera
    camera.position.set(0, 30, 25);
    camera.lookAt(0, 0, 0);

    // Target indicator
    function createTargetIndicator() {
        const geometry = new THREE.RingGeometry(0.4, 0.5, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        targetIndicator = new THREE.Mesh(geometry, material);
        targetIndicator.rotation.x = -Math.PI / 2;
        targetIndicator.visible = false;
        scene.add(targetIndicator);
    }
    createTargetIndicator();

    // UI elements
    const joinButton = document.getElementById('join-button');
    const playerNameInput = document.getElementById('player-name-input');
    const joinScreen = document.getElementById('join-screen');
    const inGameUI = document.getElementById('in-game-ui');
    const gameOverScreen = document.getElementById('game-over-screen');
    const winnerAnnouncement = document.getElementById('winner-announcement');

    joinButton.addEventListener('click', () => {
        const playerName = playerNameInput.value || "Player";
        socket.emit('joinGame', playerName);
        joinScreen.classList.add('hidden');
        inGameUI.classList.remove('hidden');
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Click to move
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener('click', (event) => {
        if (!myPlayerId) return;
        if (event.target.closest('.ui-element')) return;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(floor);
        if (intersects.length) {
            targetPosition.copy(intersects[0].point);
            targetIndicator.position.copy(targetPosition).setY(0.01);
            targetIndicator.visible = true;
        }
    });

    socket.on('connect_error', (err) => console.error("Connection Error:", err.message));
    socket.on('gameJoined', (data) => { myPlayerId = data.id; updateGameState(data.gameState); });
    socket.on('gameState', updateGameState);

    function generateLocalAnnouncement(winner) {
        const name = winner?.name || "Unknown Hero";
        const score = winner?.score ?? 0;
        const templates = [
            `${name} conquered the cubes with a heroic ${score} points! ðŸŽ‰`,
            `Triumph! ${name} finishes the round with ${score} glorious points!`,
            `${name} swept the board â€” ${score} points and a place in legend! âœ¨`,
            `Victory! ${name} scored ${score} and left the arena in awe!`
        ];
        return templates[(name.length + score + Date.now()) % templates.length];
    }

    socket.on('gameOver', (winner) => {
        inGameUI.classList.add('hidden');
        gameOverScreen.classList.remove('hidden');
        winnerAnnouncement.innerHTML = '<div class="loader"></div>';
        setTimeout(() => {
            winnerAnnouncement.innerHTML = `<p>${generateLocalAnnouncement(winner)}</p>`;
            Object.values(playerMeshes).forEach(mesh => mesh.visible = false);
            Object.values(treasureMeshes).forEach(mesh => mesh.visible = false);
            setTimeout(() => {
                gameOverScreen.classList.add('hidden');
                inGameUI.classList.remove('hidden');
            }, 10000);
        }, 600);
    });

    function updateGameState(state) {
        if (!myPlayerId) return;
        document.getElementById('timer').innerText = state.gameTimer;
        document.getElementById('leaderboard').innerHTML = state.leaderboard.map(p =>
            `<li class="flex justify-between text-gray-300 py-1">
                <span>${p.name}</span>
                <span class="font-semibold text-yellow-400">${p.score}</span>
            </li>`
        ).join('');

        const serverPlayerIds = Object.keys(state.players);
        for (const id in playerMeshes) {
            if (!serverPlayerIds.includes(id)) {
                scene.remove(playerMeshes[id]);
                delete playerMeshes[id];
            }
        }
        for (const id in state.players) {
            const pData = state.players[id];
            if (!playerMeshes[id]) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({ color: id === myPlayerId ? 0xe53e3e : 0x4299e1 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pData.x, pData.y, pData.z);
                playerMeshes[id] = mesh;
                scene.add(mesh);
            } else if (id !== myPlayerId) {
                playerMeshes[id].position.lerp(new THREE.Vector3(pData.x, pData.y, pData.z), 0.3);
            }
        }

        const serverTreasureIds = state.treasures.map(t => t.id);
        for (const id in treasureMeshes) {
            if (!serverTreasureIds.includes(id)) {
                scene.remove(treasureMeshes[id]);
                delete treasureMeshes[id];
            }
        }
        state.treasures.forEach(t => {
            if (!treasureMeshes[t.id]) {
                const geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                const material = new THREE.MeshStandardMaterial({ color: 0xf6e05e, emissive: 0xb7791f });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(t.x, t.y, t.z);
                treasureMeshes[t.id] = mesh;
                scene.add(mesh);
            }
        });
    }

    // Animation loop
    const clock = new THREE.Clock();
    const moveDirection = new THREE.Vector3();
    const targetQuat = new THREE.Quaternion();

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const now = clock.elapsedTime * 1000;
        const myPlayerMesh = playerMeshes[myPlayerId];

        if (myPlayerMesh) {
            const distance = myPlayerMesh.position.distanceTo(targetPosition);
            if (distance > 0.1) {
                moveDirection.subVectors(targetPosition, myPlayerMesh.position).normalize();
                myPlayerMesh.position.addScaledVector(moveDirection, delta * 3); // ~3 units/sec
                targetQuat.setFromUnitVectors(new THREE.Vector3(0, 0, 1), moveDirection);
                myPlayerMesh.quaternion.slerp(targetQuat, 0.15);
                socket.emit('move', myPlayerMesh.position);
            } else {
                targetIndicator.visible = false;
            }
        }

        if (targetIndicator?.visible) {
            const scale = 1 + Math.sin(now * 0.01) * 0.1;
            targetIndicator.scale.set(scale, scale, scale);
        }
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>